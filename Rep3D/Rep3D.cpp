/**
    Rep3D.cpp
    Purpose: Rep3D class, projection of repetitions found in 2D to 3D
    needs a point cloud and detected repetitions in 2D
    as described in readme file.

    @authors Pascal Enderli, Lukas Frischknecht, Timothy Marvel
    @version 1.0 6/01/17
*/
#include "Rep3D.h"

Rep3D::Rep3D()
{
    n_images	= 0;								
    n_3Dpoints	= 0;
}

///-------READING DATA
void Rep3D::read(string fullfilename_colmap_images,string fullfilename_colmap_points3D,string fullfilename_colmap_cameras, string fullFolderName_rep_folder)
{
	// combine all read in methods (order of function call matters!)
	read_images_txt(fullfilename_colmap_images);
	read_points3D_txt(fullfilename_colmap_points3D);
	read_camera_txt(fullfilename_colmap_cameras);
	readRepFiles(fullFolderName_rep_folder);
	//readRepData(fullFolderName_rep_folder);
}

/*
    Reads in IMAGE_ID, QW, QX, QY, QZ, TX, TY, TZ, CAMERA_ID, NAME
    and features for every image POINTS2D[] as (X, Y, POINT3D_ID)
    from images.txt generated by colmap
 */
void Rep3D::read_images_txt(string path)
{
	clock_t timer = time(0);
	cout<<endl<<"reading images.txt..."<<endl;
	cout <<"reading Path is: "<<path <<endl;
	const int line_offset=4; 	//images.txt has 4 header lines
	int n_lines = 0;			//number of lines of the text file
	ifstream file;				//defines a file stream
	string line;				//safe a read line temporarily
	string token;				//safe a token temporarily
	size_t first_space;			//position of the space delimiter
	Quaternionf Q;

	file.open(path.c_str());
	
	// Is it possible to open the file ?
	if(!file.is_open())
	{
		cout<<"error: could not open images.txt"<<endl;
	}
	
	// Count number of Lines in the file
	while(getline(file, line))
	{
		++n_lines;
	}

	file.close();
	n_images=(n_lines-line_offset)/2;
	cout<<"images.txt "<<n_lines<<" lines "<<"and "<<n_images<<" images."<<endl;
	
	colrep_data.resize(n_images);  //contains all colmap information (picture by picture)
	
	file.open(path.c_str());
	
	//don't read line 1-4
	for(int i=0; i<line_offset; i++)
	{
		getline(file, line);
	}

        for (int i = 0; i < n_images; i++)						//iterate in vector images_colmap for all images i and store information
        {
            loadBar(i,n_images);
            // read odd line (line 5 first )
            getline(file, line);

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            colrep_data[i].image_ID = atoi(token.c_str()); 		//safe extracted image ID

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            Q.w() = atof(token.c_str());    					//safe extracted QW

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            Q.x() = atof(token.c_str());   						//safe extracted QX

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            Q.y() = atof(token.c_str());    					//safe extracted QY

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            Q.z() = atof(token.c_str());    					//safe extracted QZ

            colrep_data[i].R=Q.normalized().toRotationMatrix();

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            colrep_data[i].T(0) = atof(token.c_str());    		//safe extracted TX

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            colrep_data[i].T(1) = atof(token.c_str());    		//safe extracted TY

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            colrep_data[i].T(2) = atof(token.c_str());    		//safe extracted TZ

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            colrep_data[i].camera_ID = atoi(token.c_str());		//safe extracted Camera ID

            first_space = line.find_first_of(" ");         		//find first token in the line
            token = line.substr(0, first_space);           		//safe the part before the white space as token
            line = line.substr(first_space + 1);           		//just keep the line part after the white space
            colrep_data[i].image_name = token;             		//safe extracted image name


            // read even line (line 6 first )
            getline(file, line);
            line.push_back('$'); //add end character


            while (line[line.find_first_of(" $")] !='$')       						//while the next separator is not $ (end of line)
            {
                first_space = line.find_first_of(" ");         						//find first token in the line
                token = line.substr(0, first_space);           						//safe the part before the white space as token
                line = line.substr(first_space + 1);								//just keep the line part after the white space
                colrep_data[i].featureCoord.u.push_back(atof(token.c_str()));    	// store first token as u (float)

                first_space = line.find_first_of(" ");
                token = line.substr(0, first_space);
                line = line.substr(first_space + 1);
                colrep_data[i].featureCoord.v.push_back(atof(token.c_str()));		// store second token as v
             

                first_space = line.find_first_of(" ");
                token = line.substr(0, first_space);
                line = line.substr(first_space + 1);
                colrep_data[i].featureCoord.ID_3D.push_back(atof(token.c_str()));	// store third token as ID_3D

            }

            colrep_data[i].n_2Dpoints = colrep_data[i].featureCoord.ID_3D.size();    //safe extracted image ID n_2Dpoints
            colrep_data[i].featureCoord.point3D.resize(colrep_data[i].n_2Dpoints);	//adapt 3D cloud pointer vector size for each picture
        }
	file.close();
	float t =difftime( time(0), timer);
	cout<<endl<<"read_images_txt done! ["<<t<<" sec]"<<endl;
}


/*
    Reads in 3D points POINT3D_ID, X, Y, Z
    from points3D.txt generated by colmap
 */
void Rep3D::read_points3D_txt(string path)
{
	clock_t timer = time(0);
	cout<<endl<<"reading Points3D.txt..."<<endl;
	cout <<"reading Path is: "<<path <<endl;

	ifstream file;				//defines a file stream
	int n_lines = 0;			//number of lines of the textfile
	string line;
	string token;
	size_t first_space;			//position of the space delimiter
	int line_offset=3; 			//images.txt has 3 header lines

	file.open(path.c_str());

	// Is it possible to open the file ?
	if(!file.is_open())
	{
		cout<<"error: could not open images.txt"<<endl;
	}

	// Count number of Lines in the file
	while(getline(file, line))
	{
		++n_lines;
	}
	file.close();
	n_3Dpoints=n_lines-line_offset;
	cout<<"points3D.txt has "<<n_lines<<" lines "<<"and "<<n_3Dpoints<<" 3D points."<<endl;


	file.open(path.c_str());

	//don't read line 1-3
	for(int i=0; i<line_offset; i++)
	{
		getline(file, line);
	}

	pointCloud.resize(n_3Dpoints);

	//iterate over all 3Dpoints i in the file and set the pointer from 2D feauture to 3D point
	for(int i=0; i<n_3Dpoints;i++)
	{

		loadBar(i,n_3Dpoints);
		getline(file, line);

		first_space = line.find_first_of(" "); 					//find first token in the line
		token = line.substr(0,first_space);	 					//safe the part before the white space as token
		line  = line.substr(first_space+1,line.length());		//just keep the line part after the white space
        pointCloud[i].ID_3D = atof(token.c_str());				//add to pointCloud container also for fast access

		first_space = line.find_first_of(" ");
		token = line.substr(0,first_space);
		line  = line.substr(first_space+1,line.length());
		pointCloud[i].X = atof(token.c_str());

		first_space = line.find_first_of(" ");
		token = line.substr(0,first_space);
		line  = line.substr(first_space+1,line.length());
        pointCloud[i].Y = atof(token.c_str());

		first_space = line.find_first_of(" ");
		token = line.substr(0,first_space);
		line  = line.substr(first_space+1,line.length());
        pointCloud[i].Z = atof(token.c_str());
	}
	file.close();
    assign3Dpoints();

	float t =difftime( time(0), timer);
	cout<<"read_points3D_txt done! ["<<t<<" sec]"<<endl;
}



/*
    Reads cameras: CAMERA_ID, MODEL, WIDTH, HEIGHT, PARAMS[]
    from cameras.txt generated by colmap
 */
void Rep3D::read_camera_txt(string path)
{
    clock_t timer = time(0);
    cout<<endl<<"Read out calibration matrix..."<<endl;
    cout <<"reading Path is: "<<path <<endl;

    if((n_images||n_3Dpoints)==0)
    {
        cerr<<"call the function void read_colmap() first"<<endl;
        exit(0);
    }

    string 	cameramodel;			//expected camera parameters: simple_radial camera model: <f, cx, cy, k1, k2>
    string 	line;
    string 	token;
    int 	Cam_ID;
    int 	n_lines=0;
    int		n_cameras=0;
    int 	line_offset=3;
    ifstream file;					//defines a file stream
    size_t 	first_space;
    float 	f;
    float 	cx;
    float 	cy;
    float 	k;

    file.open(path.c_str());

    // Is it possible to open the file ?
    if(!file.is_open())
    {
        cout<<"error: could not open cameras.txt"<<endl;
    }
    else
    {
        // Count number of Lines in the file
        while(getline(file, line))
        {
            ++n_lines;
        }
        n_cameras=n_lines-line_offset;
    }
    file.close();


    file.open(path.c_str());
    //don't read line 1-3
    for(int i=0; i<line_offset; i++)
    {
        getline(file, line);
    }

    for(int i=0;i<n_cameras;i++)
    {
        loadBar(i,n_cameras);
        getline(file, line);

        //read camera model
        first_space = line.find_first_of(" "); 						//find first token in the line
        token = line.substr(0,first_space);	 						//safe the part before the white space as token
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        Cam_ID=atof(token.c_str());									// store first token as camera model (string)

        //read camera model
        first_space = line.find_first_of(" "); 						//find first token in the line
        token = line.substr(0,first_space);	 						//safe the part before the white space as token
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        cameramodel=token;											// store first token as cameramodel (string)
        if(cameramodel.compare("SIMPLE_RADIAL")!=0)
        {
            cerr<<"Expected camera model is: SIMPLE_RADIAL! Instead "<<cameramodel.c_str()<<" was used"<<endl;
            exit (0);
        }


        //don't read WIDTH
        first_space = line.find_first_of(" "); 						//find first token in the line
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        //don't read HEIGHT
        first_space = line.find_first_of(" "); 						//find first token in the line
        line  = line.substr(first_space+1);							//just keep the line part after the white space

        //read f
        first_space = line.find_first_of(" "); 						//find first token in the line
        token = line.substr(0,first_space);	 						//safe the part before the white space as token
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        f=atof(token.c_str());										//store f focal length

        //read cx
        first_space = line.find_first_of(" "); 						//find first token in the line
        token = line.substr(0,first_space);	 						//safe the part before the white space as token
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        cx=atof(token.c_str());										//store principal point

        //read cy
        first_space = line.find_first_of(" "); 						//find first token in the line
        token = line.substr(0,first_space);	 						//safe the part before the white space as token
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        cy=atof(token.c_str());										//store principal point

        //read k
        first_space = line.find_first_of(" "); 						//find first token in the line
        token = line.substr(0,first_space);	 						//safe the part before the white space as token
        line  = line.substr(first_space+1);							//just keep the line part after the white space
        k=atof(token.c_str());										//store distortion parameter
        //overwrite
        //merge(Cam_ID,f,cx,cy,k);
        merge(Cam_ID,f,cx,cy,k);
    }
    file.close();

    float t =difftime( time(0), timer);
    cout<<endl<<"read_camera_tex done! ["<<t<<" sec]"<<endl;
}



/*
    Assigns 2D points on images to corresponding 3D points if 3D point exists
    if not points to NULL
 */
void Rep3D::assign3Dpoints(void){
    int i,k,j;

    cout <<endl<<"assigning 3D points to 2D points..." << endl;

    #pragma omp parallel for private(k,j)
    for(i=0; i<n_images;i++) 					   // for all images i
    {
        for(k=0; k<colrep_data[i].n_2Dpoints; k++) //for every 2D Coordinate k
        {
            // check if ID needs too be found at all before looping
            if(colrep_data[i].featureCoord.ID_3D[k]!=-1)
            {

                for(j=0;j<n_3Dpoints;j++) //for all 3D featureCoord
                {
                    if(colrep_data[i].featureCoord.ID_3D[k]==pointCloud[j].ID_3D)
                    {
						//writting must be protected from race condtions
						#pragma omp critical
						{
                        colrep_data[i].featureCoord.point3D[k] = &pointCloud[j];
						}
						break;
                    }
                }
            }
            else
            {
            	colrep_data[i].featureCoord.point3D[k]=nullptr;
            }
        }
    }
}


/*
    _?
 */
void Rep3D::merge(int Cam_ID, float f,float cx, float cy, float k) // 2D info is in member variable
{
	//#pragma omp parallel for
	for(int i=0; i<n_images;i++) 					   // for all images i
	{		
			
			if(Cam_ID==colrep_data[i].camera_ID)	   // determine K camera calibration matrix
	//		#pragma omp critical
			{
				colrep_data[i].K(0,0)=f;
				colrep_data[i].K(0,1)=0;
				colrep_data[i].K(0,2)=cx;
				colrep_data[i].K(1,0)=0;
				colrep_data[i].K(1,1)=f;
				colrep_data[i].K(1,2)=cy;
				colrep_data[i].K(2,0)=0;
				colrep_data[i].K(2,0)=0;
				colrep_data[i].K(2,2)=1;

				colrep_data[i].k=k;
			}
			
	}
}

/*
    reads .rep and .rep2 files stored in folderLocation and stores to repData struct for each image
 */
void Rep3D::readRepFiles(string folderLocation) {


    //temp vars, note some are declared on the fly
    string token;
    size_t first_space;
    int sizeOfCD = colrep_data.size();
    int imageIndex;
    struct dirent *file;
    DIR *directory;

    //some communication
    cout << endl << "Read out Rep Data..." << endl;
    cout << "reading Path is: " << folderLocation << endl;
    cout << "this is the size of colrepData " << sizeOfCD << endl;
    cout << "started to read rep" << endl;

    //opens the direcotry with the propper path
    string myLocalDir = folderLocation;
    directory = opendir(myLocalDir.c_str());

    if (directory == NULL) {
        cout << "error: could not find dir" << endl;
    }

    //open the files and process
    while ((file = readdir(directory)) != NULL) {
        //cout << file->d_name << endl;

        string fileName = file->d_name;

        //find the .rep2 file only and read their input
        if (fileName.substr(fileName.find_last_of(".") + 1) == "rep2") {
            //find the image associated to the rep
            string imgName = fileName.substr(0, fileName.find_last_of("."));
            imgName = imgName + ".JPG";

            //read the file
            ifstream file;
            string fileNameAdded = myLocalDir + "/" + fileName;

            bool found = false;
            for (int i = 0; i < sizeOfCD; ++i) {
                string tempstring = "images/" + imgName + "\r";
                if (colrep_data[i].image_name == imgName || colrep_data[i].image_name == tempstring) {
                    found = true;
                    imageIndex = i;
                    break;
                }
            }
            if (found) {

                //local repdata
                file.open(fileNameAdded.c_str());
                if (!file.is_open()) {
                    cout << "error: could not open  rep2" << endl;
                } else {
                    string rep2line;
                    vector<string> theActualData;
                    //check what is on the first line if its zero don't go any further
                    getline(file, rep2line);
                    if (rep2line == "0") {
                        colrep_data[imageIndex].numberOfReps = 0;
                    } else {
                        //open rep1 file also to get structure
                        ifstream file_rep1;
                        string fileNameRep1 =
                                myLocalDir + "/" + fileName.substr(0, fileName.find_last_of(".")) + ".rep";
                        file_rep1.open(fileNameRep1.c_str());
                        if (!file_rep1.is_open()) {
                            cout << "error: could not open .rep file" << endl;
                            cout << "this is filename " << fileNameRep1 << endl;
                        }

                        else
                        {
                            int repAmount = std::atof(rep2line.c_str());


                            colrep_data[imageIndex].numberOfReps = repAmount;

                            // temporarly read in .rep file as pair vector for easy handling in furter steps
                            // get length of file stored in first line of the .rep file
                            string repLine;
                            getline(file_rep1, repLine);
                            int tempLen = std::atof(repLine.c_str());
                            vector<pair<float,float>> tempRepVect;
                            pair<float,float> tempFilePair;
                            for(int i=0;i<tempLen;i++)
                            {
                                getline(file_rep1, repLine);
                                first_space = repLine.find_first_of(" ");
                                token = repLine.substr(0,first_space);
                                repLine  = repLine.substr(first_space+1,repLine.length());
                                tempFilePair.first = atof(token.c_str());


                                first_space = repLine.find_first_of(" ");
                                token = repLine.substr(0,first_space);
                                tempFilePair.second = atof(token.c_str());

                                //ignore 0,0 pairs, since used as delimiter (strange delimiters btw but given in file provided)
                                if(tempFilePair.first==0 and tempFilePair.second==0) {}
                                else
                                {
                                    tempRepVect.push_back(tempFilePair);
                                }

                            }

                            //allocate memory for number of repetitions
                            colrep_data[imageIndex].repetitions.resize(repAmount);

                            // now get the size of the rep from the rep2 file
                            // initialize idxBegin with 0, will later be used to know where to start to read, see below
                            int idxBegin = 0;

                            for(int j=1;j<=repAmount;j++) {

                                getline(file, rep2line); // 2nd line now in .rep file since already opened above
                                int first_dot = rep2line.find_first_of(".");
                                rep2line = rep2line.substr(0, first_dot);
                                int lastSpace = rep2line.find_last_of(" ");
                                string lineX = rep2line.substr(lastSpace - 2, lastSpace);
                                string lineY = rep2line.substr(lastSpace, lastSpace + 2);
                                int nrOfVertLines = std::atof(lineX.c_str()) + 1; //store the number of vertical lines
                                int nrOfHorLines = std::atof(lineY.c_str()) + 1; //store the bumber of horizontal lines

                                //set rep id
                                colrep_data[imageIndex].repetitions[j - 1].repID=imgName+"_repNr_"+to_string(j);

                                //store nr of lines to struct
                                colrep_data[imageIndex].repetitions[j - 1].n_vertLines = nrOfVertLines;
                                colrep_data[imageIndex].repetitions[j - 1].n_horLines = nrOfHorLines;

                                //calculate the indeces to be read from temRepArray and stored into the rep.repetions
                                int idxEnd = idxBegin+((nrOfVertLines+nrOfHorLines)*2); //note the 0,0 pairs are
                                // ignored here, since not in tempRepVect, also note that idxBegin is set to idxEnd after each iteration

                                for(int w=0;w<idxEnd-idxBegin;w++)
                                {
                                    pair<float,float> tempPair = tempRepVect[idxBegin+w];
                                    //store start points (even are end points, uneven are start points)
                                    if((w+1)%2!=0) {
                                        colrep_data[imageIndex].repetitions[j - 1].startPoints_2D.push_back(tempPair);
                                    }
                                    else {
                                        //store end points
                                        colrep_data[imageIndex].repetitions[j - 1].endPoints_2D.push_back(tempPair);
                                    }
                                }
                                //set start index for next iteration to current end index+1
                                idxBegin = idxEnd;
                            }

                        }
                    }
                }
            }
        }
    }
    cout << "Done reading rep files!" << endl;
}



///-------DATA PROCESSING

/*
    Returns Eigen MatrixXf with 3D points [ID_3D, X, Y, Z]
 */
MatrixXf Rep3D::get_3D_data(void)
{
	clock_t timer = time(0);
	cout<<endl<<"Search for 3D Datapoints..."<<endl;

	MatrixXf result = MatrixXf::Zero(n_3Dpoints, 4);    //store result

	for(int i=0;i<n_3Dpoints;i++)
    {
        loadBar(i,n_3Dpoints);
        result(i, 0) = pointCloud[i].ID_3D;
		result(i, 1) = pointCloud[i].X;
		result(i, 2) = pointCloud[i].Y;
		result(i, 3) = pointCloud[i].Z;
	}

	float t =difftime( time(0), timer);
	cout<<endl<<"get_3D_data done! ["<<t<<" sec]"<<endl;
	return result;
}

/*
    Performs plane fit on 3D point Eigen MatrixXf
    returns a plane struct
 */
Rep3D::plane Rep3D::RANSAC_plane(MatrixXf points)
{
	//points is the subset of points in 3D which seem to be inside a rep in 2D [X,Y,Z]
	//E=P+a*e1+b*e2 [a;b are free parameters]

	plane result;
	int m=points.rows();						//number of given 3D points [X,Y,Z]
	float error;
	float min_error=0;							//minimal error
	float d;									//distance of point to plane
	Vector3f P;
	Vector3f e1;
	Vector3f e2;
	Vector3f n;									//normalvector
	Vector3f diff;								//difference of point in plane with other point
	float tmp;									//temporary storage
	int n_it=30;								//nr of RANSAC iterations
	float  rho;


	for(int k=0;k<n_it;k++)						//for  every RANSAC iteration n_it calc a plane from 3 random points and calc its error
	{
		error=0;
		int rand1;
		int rand2;
		int rand3;

		rand1 = rand() % (m);				// choose 3 rand numbers to choose 3 random points from the cloud

		do
		{
		rand2 = rand() % (m);
		}while(rand1==rand2);

		do
		{
		rand3 = rand() % (m);
		}while(rand3==rand1 || rand3==rand2);

		P=(Vector3f)points.row(rand1);			//choose the three random points and define plane parameter description in earth system
		e1=(Vector3f)points.row(rand2)-P;
		e2=(Vector3f)points.row(rand3)-P;
		e1=e1.normalized();
		e2=e2.normalized();

		//find error of this plane in respect of all the other points i.
		for(int i=0;i<m;i++)
		{
			n=e1.cross(e2);
			diff=(Vector3f)points.row(i)-P;
			tmp=n.dot(diff);
			tmp=abs(tmp);
			d=tmp/n.norm();						// d=|n*(Q-P)|/|n| q is an external point, p is a point in the plane

			error=error+(d*d)/m; 				//normalize squared error with nr of 3D points

			if(error<min_error || min_error == 0) //save the parameters of the plane with the smallest error. 
			{
				min_error=error;
				result.P=P;
				result.e1=e1;
				result.e2=e2;
			}
		}
	}
    Vector3f ne3=result.e1.cross(result.e2);
    ne3=ne3.normalized();

    rho = result.P.dot(ne3);
    if(rho<0)
    {
    	ne3 =-ne3;
    }
    result.ne3 = ne3;

	return result;
}


/*
    solve LGS for alpha;beta and calc projected 3d point (E)
	LGS Ax=b; solve for x=[lambda; lambda*alpha; lambda*beta]
 */
pair<Vector3f,pair<float,float>> Rep3D::LGS(float u, float v, plane E,Vector3f* T,Matrix3f* K, Matrix3f* R)
{



	Vector3f point_world_KOS;      // coordinate of point in world KOS
	pair<float,float> point_plane_KOS;      // coordinate of point in plane KOS
	Vector3f b(u,v,1);
	Matrix3f A; A<<(*K)*(*R)*(E.P)+(*K)*(*T),(*K)*(*R)*(E.e1),(*K)*(*R)*(E.e2);
	Vector3f x;


	float alpha;
	float beta;
	
	x=A.colPivHouseholderQr().solve(b); 	//solve LGS Ax=b
	alpha= x(1)/x(0);						// coordinate of point in plane KOS
	beta = x(2)/x(0);

	point_world_KOS=E.P+ alpha*E.e1+ beta*E.e2;		// coordinate of point in world KOS
	point_plane_KOS.first=alpha;
	point_plane_KOS.second=beta;

	pair<Vector3f,pair<float,float>> result(point_world_KOS,point_plane_KOS);

	return result;
}

/*
    calculates the projection planes using RANSAC_plane() for all features within repetition
    which also have a corresponding 3D point
 */
void Rep3D::calc_proj_planes(void)
{
	clock_t timer = time(0);
	cout<<endl<<"Calculate 3D projection planes for every repetition..."<<endl;

	for(int i=0;i<n_images;i++)											//for every image i
	{
		for(int j=0;j<colrep_data[i].numberOfReps;j++)				//for every repetition j
		{
			//find subset of 3Dpoints which belong to a 2D rep
			//define rep space in 2D polygon with four corners x and coresponding y featureCoord clockwise
			float polyX[4];
			float polyY[4];

            polyX[0]=colrep_data[i].repetitions[j].startPoints_2D[0].first;//topleft corner
            polyX[1]=colrep_data[i].repetitions[j].endPoints_2D[colrep_data[i].repetitions[j].n_vertLines].first;//topright
            polyX[2]=colrep_data[i].repetitions[j].endPoints_2D.back().first;//bottomright
            polyX[3]=colrep_data[i].repetitions[j].endPoints_2D[0].first;//bottomleft

            polyY[0]=colrep_data[i].repetitions[j].startPoints_2D[0].second;
            polyY[1]=colrep_data[i].repetitions[j].endPoints_2D[colrep_data[i].repetitions[j].n_vertLines].second;
            polyY[2]=colrep_data[i].repetitions[j].endPoints_2D.back().second;
            polyY[3]=colrep_data[i].repetitions[j].endPoints_2D[0].second;
			
			//Fill matrix with all 3D points which have their projections inside the rep area in 2D
			vector<float> X;
			vector<float> Y;
			vector<float> Z;

			for(unsigned int k=0;k<colrep_data[i].featureCoord.u.size();k++) //for all 2D feautures k
			{
				if(inPolygon(polyX, polyY,
                             colrep_data[i].featureCoord.u[k],colrep_data[i].featureCoord.v[k],4) && colrep_data[i].featureCoord.point3D[k] != nullptr)
				{
					X.push_back(colrep_data[i].featureCoord.point3D[k]->X);
					Y.push_back(colrep_data[i].featureCoord.point3D[k]->Y);
					Z.push_back(colrep_data[i].featureCoord.point3D[k]->Z);
				}
				else if(inPolygon(polyX, polyY,
                                  colrep_data[i].featureCoord.u[k],colrep_data[i].featureCoord.v[k],4)){
				}
			}

			unsigned int n_rep_inliers=X.size();				//number of 2D feautures inside the area of rep j
			MatrixXf points(n_rep_inliers,3);

			if(n_rep_inliers<3)
			{
				//uncomment if name of reps with usless data should be output
				//cout<<"There are less than 3 Inliers in rep with ID: "<<colrep_data[i].repetitions[j].repID<<","<<endl;
				colrep_data[i].repetitions[j].planeptr=nullptr;
			}
			else
			{
				//#pragma omp parallel for
				for(unsigned int k=0;k<n_rep_inliers;k++) 			//parse data for RANSAC_plane function
				{
					points(k,0)=X[k];
					points(k,1)=Y[k];
					points(k,2)=Z[k];
				}

				//extract plane of picture i and rep j
				plane E = RANSAC_plane(points);  //points [X,Y,Z] are subset of 3D points which seem to be inside 2D Rep
				planes.push_back(E);					//add plane to list
				planes.back().index=planes.size()-1;	//save information about the index of the cell in the list
				colrep_data[i].repetitions[j].planeptr = &(planes.back()); //point to plane

			}
		}
	}
	float t =difftime( time(0), timer);
	cout<<endl<<"calc_proj_planes done! ["<<t<<" sec]"<<endl;
}

/*
    projects repetitions into 3D using LGS
 */
void Rep3D::project_raw_reps(void)
{
	//clock_t timer = time(0);
	cout<<endl<<"Project Repetitions to 3D..."<<endl;

	for(int i=0;i<n_images;i++)												// for every image i
	{
		loadBar(i,n_images);

		for(int j=0;j<colrep_data[i].numberOfReps;j++)						// for every repetition j
		{
			if(colrep_data[i].repetitions[j].planeptr!=nullptr)
			{
				int n_rep_lines=colrep_data[i].repetitions[j].startPoints_2D.size(); 	// number of defined lines of the rep

				colrep_data[i].repetitions[j].startPoints_3D.resize(n_rep_lines);
				colrep_data[i].repetitions[j].endPoints_3D.resize(n_rep_lines);
				for (int k=0; k<n_rep_lines;k++)  											// for every rep line
				{
					float u_start=colrep_data[i].repetitions[j].startPoints_2D[k].first;
					float v_start=colrep_data[i].repetitions[j].startPoints_2D[k].second;

					float u_end=colrep_data[i].repetitions[j].endPoints_2D[k].first;
					float v_end=colrep_data[i].repetitions[j].endPoints_2D[k].second;
					
					//no radial distortion
					
					//calculate Projection (solve LGS) of point P in 3D
					pair<Vector3f,pair<float,float>> proj_point_start = LGS(u_start, v_start, *colrep_data[i].repetitions[j].planeptr, &colrep_data[i].T, &colrep_data[i].K, &colrep_data[i].R);
					pair<Vector3f,pair<float,float>> proj_point_end = LGS(u_end, v_end, *colrep_data[i].repetitions[j].planeptr, &colrep_data[i].T, &colrep_data[i].K, &colrep_data[i].R);

					//safe projected point in a rep3D data structure (one should be able to plot the 3d rep pattern)
					colrep_data[i].repetitions[j].startPoints_3D[k].ID_3D=0; 			//ID_3D is not needed
					colrep_data[i].repetitions[j].startPoints_3D[k].X=proj_point_start.first.x();
					colrep_data[i].repetitions[j].startPoints_3D[k].Y=proj_point_start.first.y();
					colrep_data[i].repetitions[j].startPoints_3D[k].Z=proj_point_start.first.z();

					colrep_data[i].repetitions[j].endPoints_3D[k].ID_3D=0; 				//ID_3D is not needed
					colrep_data[i].repetitions[j].endPoints_3D[k].X=proj_point_end.first.x();
					colrep_data[i].repetitions[j].endPoints_3D[k].Y=proj_point_end.first.y();
					colrep_data[i].repetitions[j].endPoints_3D[k].Z=proj_point_end.first.z();
				}

                //store corners also for easy access
                colrep_data[i].repetitions[j].corners.push_back(colrep_data[i].repetitions[j].startPoints_3D[0]);//topleft
                colrep_data[i].repetitions[j].corners.push_back(colrep_data[i].repetitions[j].endPoints_3D[colrep_data[i].repetitions[j].n_vertLines]);//topright
                colrep_data[i].repetitions[j].corners.push_back(colrep_data[i].repetitions[j].endPoints_3D.back());//bottomright
                colrep_data[i].repetitions[j].corners.push_back(colrep_data[i].repetitions[j].endPoints_3D[0]);//bottomleft

				colrep_data[i].repetitions[j].valid=true;
				reps.push_back(colrep_data[i].repetitions[j]);							//add rep to reps list
				reps.back().planeptr= colrep_data[i].repetitions[j].planeptr;			//point to plane
				reps.back().image_ptr= &colrep_data[i];									//point to image
				planes[colrep_data[i].repetitions[j].planeptr->index].rep_ptr.push_back(&(reps.back())); //add this rep as a member of its plane (pointer)
			}
		}
	}
	//float t =difftime( time(0), timer);
}


/*
    perfoms a hough transform on every plane
 */
MatrixXf Rep3D::Hough_TF(void)
{
	int n_planes=planes.size();
	MatrixXf result(n_planes,4);   //[valid;rho;phi;theta]
	Vector3f diff;

	for(int i=0;i<n_planes;i++)
	{

		if(plane_is_valid(planes[i])==true)
		{
			float    rho = planes[i].P.dot(planes[i].ne3);

			vector<float> polar = Kart_To_Sph(planes[i].ne3); //[rho; phi; theta]

			//[valid;phi;theta;rho]
			result(i,0)=1;
			result(i,1)=rho;
			result(i,2)=polar[1];
			result(i,3)=polar[2];
		}
		else
		{
			result(i,0)=0;				//valid plane or not
			result(i,1)=0;
			result(i,2)=0;
			result(i,3)=0;
		}
	}

	return result;
}


/*
    perfoms an inverse hough transform
 */
Rep3D::plane Rep3D::Hough_back_TF(vector<float> Hough) //input: v=[rho;phi;theta]
{
	plane result;
	vector<float> ne_kart(3);

	float rho = Hough[0];
	ne_kart=Sph_To_Kart(Hough); //[x,y,z] of normalen vector
	ne_kart[0]=ne_kart[0]/rho;//sqrt(ne_kart[0]*ne_kart[0]+ne_kart[1]*ne_kart[1]+ne_kart[2]*ne_kart[2]); //normalize
	ne_kart[1]=ne_kart[1]/rho;
	ne_kart[2]=ne_kart[2]/rho;

	result.e1(0)=0;
	result.e1(1)=ne_kart[2];
	result.e1(2)=-ne_kart[1];
	result.e1=result.e1.normalized();

	result.e2(0)=ne_kart[2];
	result.e2(1)=0;
	result.e2(2)=-ne_kart[0];
	result.e2=result.e2.normalized();

	result.P(0)=rho*ne_kart[0];
	result.P(1)=rho*ne_kart[1];
	result.P(2)=rho*ne_kart[2];

	return result;
}


/*
    finds all facades of the building
 */
void Rep3D::find_optimal_plane(void)
{
    cout<<endl<<"Find optimal planes..."<<endl;
    clock_t timer = time(0);

    //Transform Planes in Hough domain
	MatrixXf Hough = Hough_TF();

	//-----------------------------------

	//Normalize Hough space;
	float k_rho  =Hough.col(1).maxCoeff()-Hough.col(1).minCoeff();
	float k_phi  =Hough.col(2).maxCoeff()-Hough.col(2).minCoeff();
	float k_theta=Hough.col(3).maxCoeff()-Hough.col(3).minCoeff();


	Hough.col(1)=1/k_rho  *Hough.col(1);
	Hough.col(2)=1/k_phi  *Hough.col(2);
	Hough.col(3)=1/k_theta*Hough.col(3);
	//-----------------------------------

	int n_planes=Hough.rows();  //total inkl invalid planes

	for(int i=0;i<n_planes;i++)
	{
		if(Hough(i,0)!=0)
		{
			//cout<<Hough.block<1,3>(i,1)<<endl;
		}
	}

	float eps = 0.017;   //can be constant since houg space is normalized
	size_t min_elems = 6;
	float rho_mean;
	float phi_mean;
	float theta_mean;
	float divisor;
	int inlier=0;
	int outlier=0;
	size_t n_reps;
	plane E;

	//clustering
	clustering::DBSCAN<VectorXf, MatrixXf> cloud(eps, min_elems);
	cloud.fit( Hough );
	vector<int> Labels = cloud.get_labels();
	int n_clusters=max<int>(Labels)+1;
	//-----------------------------------

	//denormalize
	Hough.col(1)=k_rho  *Hough.col(1);
	Hough.col(2)=k_phi  *Hough.col(2);
	Hough.col(3)=k_theta*Hough.col(3);
	//------------------------------------

	vector<float> Hough_mean(3);

	//calculate mean plane parameter for every cluster index
	for(int i=0;i<n_clusters;i++)
	{
		phi_mean=0;		//reset mean
		theta_mean=0;
		rho_mean=0;
		divisor=1;
		for(int j=0;j<n_planes;j++)	//for every plane in Hough domain
		{
			if(Hough(j,0)==1 && Labels[j]==i && false==isnan(Hough(j,1)) )//if plane is valid and belongs to that cluster
			{
				rho_mean  =rho_mean  +1/divisor*(Hough(j,1)-rho_mean);
				phi_mean  =phi_mean  +1/divisor*(Hough(j,2)-phi_mean);
				theta_mean=theta_mean+1/divisor*(Hough(j,3)-theta_mean);
				divisor++;
			}
			else if((Hough(j,0)==1 && Labels[j]==-1) || true==isnan(Hough(j,1)) )		//if rep lies in a plane which was not clustered
			{
				reps[j].valid=false;					//index of reps and planes are identical
				n_reps=planes[j].rep_ptr.size();
				for(unsigned int k=0;k<n_reps;k++)				//for all connected reps to that plane
				{
					if(planes[j].rep_ptr[k]==&reps[j])
					{
						planes[j].rep_ptr[k]=nullptr;
					}
					else{}
				}
				reps[j].planeptr=nullptr;				//set plane pointer to NULL
			}
			else{}
		}

		if(divisor>1)		//if plane is valid add plane to deque and set pointers and index
		{
		    Hough_mean[0]=rho_mean;
		    Hough_mean[1]=phi_mean;
		    Hough_mean[2]=theta_mean;
		    E = Hough_back_TF(Hough_mean);

		    //add planes to deque and assign reps to them;
		    E.index=planes.back().index+1;
		    planes.push_back(E);

		    size_t n_reps=reps.size();
		    for(unsigned int j=0;j<n_reps;j++) //for all reps
		    {
		    	if(reps[j].valid==true && Labels[j]==i) //if rep is valid, and its plane belongs to that cluster (index of reps and planes are identical)
		    	{
		    		planes.back().rep_ptr.push_back(&reps[j]);
		    		reps[j].planeptr=&planes.back();
		    	}
		    }
		}
		else{}
	}
	float t =difftime( time(0), timer);


	//Cluster info
	for(int i=0;i<n_planes;i++)
	{
		if(Hough(i,0)==1 && Labels[i]>-1)
		{
			inlier++;
		}
		else if(Labels[i]==-1)
		{
			outlier++;
		}
	}
	cout<<endl<<"Each Cluster contains the Data of one optimal plane "<<endl;
	cout<<"Nr. of clustered Planes: "<<inlier<<endl<<"Nr. of Cluster Outliers:"<<outlier<<endl<<"Nr. of Clusters: "<<n_clusters<<endl;
	//setting the member variable
	n_MainPlanes=n_clusters;


	cout<<"find_optimal_plane done! ["<<t<<" sec]"<<endl;
}
/*
    project repetitions on the facades
 */
void Rep3D::project_optimal_reps(void)
{
	int size=reps.size();
	for(int i=0;i<size;i++)		//for every  rep
	{
		if(reps[i].valid==true) // Which is valid
		{
			int n_rep_lines=reps[i].startPoints_2D.size(); 	// number of defined lines of the rep

			reps[i].startPoints_3D.resize(n_rep_lines);
			reps[i].endPoints_3D.resize(n_rep_lines);
			reps[i].startAlphaBeta.resize(n_rep_lines);
			reps[i].endAlphaBeta.resize(n_rep_lines);
			for (int k=0; k<n_rep_lines;k++)  						// for every rep line
			{
					float u_start=reps[i].startPoints_2D[k].first;
					float v_start=reps[i].startPoints_2D[k].second;

					float u_end=reps[i].endPoints_2D[k].first;
					float v_end=reps[i].endPoints_2D[k].second;

					//no radial distortion

					//calculate Projection (solve LGS) of point P in 3D
					pair<Vector3f,pair<float,float>> proj_point_start = LGS(u_start, v_start, *reps[i].planeptr, &(reps[i].image_ptr->T), &(reps[i].image_ptr->K), &(reps[i].image_ptr->R));
					//filling the alpha beta info using member variable
					reps[i].startAlphaBeta[k]=proj_point_start.second;
				
					pair<Vector3f,pair<float,float>> proj_point_end =   LGS(u_end,   v_end,   *reps[i].planeptr, &(reps[i].image_ptr->T), &(reps[i].image_ptr->K), &(reps[i].image_ptr->R));
					//filling the alpha and beta using the member variable
					reps[i].endAlphaBeta[k]=proj_point_end.second;
					//safe projected point in a rep3D data structure (one should be able to plot the 3d rep pattern)
					reps[i].startPoints_3D[k].ID_3D=0; 			//ID_3D is not needed
					reps[i].startPoints_3D[k].X=proj_point_start.first.x();
					reps[i].startPoints_3D[k].Y=proj_point_start.first.y();
					reps[i].startPoints_3D[k].Z=proj_point_start.first.z();

					reps[i].endPoints_3D[k].ID_3D=0; 				//ID_3D is not needed
					reps[i].endPoints_3D[k].X=proj_point_end.first.x();
					reps[i].endPoints_3D[k].Y=proj_point_end.first.y();
					reps[i].endPoints_3D[k].Z=proj_point_end.first.z();
					
			}
		//provide direct acces to corner points points
			int indexForRCorner=-1+int(reps[i].n_vertLines);
	
			// A--------B
			// ----------
			// D--------C
			reps[i].cornerAlphaBeta.push_back(reps[i].startAlphaBeta[0]);//ok
			reps[i].cornerAlphaBeta.push_back(reps[i].startAlphaBeta[indexForRCorner]);
			reps[i].cornerAlphaBeta.push_back(reps[i].endAlphaBeta.back());
			reps[i].cornerAlphaBeta.push_back(reps[i].endAlphaBeta[0]);//ok
	
			
		}
		else{}
	}

}

///-----repetition optimization and clustering


/*
    clusters repetitions such that equal repetitions from different images are clustered together
 */
void Rep3D::clusterReps() {

	//grab those that don't overlap and store them in loneReps
	cout<<"started cluster with overlap"<<endl;

	int wholeSize=planes.size();
	//find overlapping repetitions and store them in 
	for(int i=0;i<n_MainPlanes;i++){
		vector<singleRepetition*> belongsToWall=planes[wholeSize-i-1].rep_ptr;
		deque<singleRepetition*> tempRepPtrs;
		int stopMe=belongsToWall.size();
		for(int l=0;l<stopMe;++l){
			singleRepetition*  repA=belongsToWall[l];
			bool foundAnOvrLap=false;
			for(int m=0;m<stopMe;++m){
				singleRepetition* repB=belongsToWall[m];
				if(repA->valid && repB->valid && l!=m){
					//cout<<"called overlap"<<endl;
					if(doTheyOverLap(repA,repB)){
						foundAnOvrLap=true;
						m=stopMe;
						break;
					}
				}
			}
			if(foundAnOvrLap){
				tempRepPtrs.push_back(repA);
			}
			else{
				//cout<<"lone rep"<<endl;
				//repA->valid=false;
				//loneReps.push_back(repA);
			}
		}
		repClusters.push_back(tempRepPtrs);
	}
}


/*
  main function for finding optimal repetition representation
 */
void Rep3D::find_optrep(){

	//first cluster repetitions
	clusterReps();


	cout<<"cout finished overlap check"<<endl;

	//apply voting scheme
	int VOTING_ROUNDS=2;
	for(int out=0;out<VOTING_ROUNDS;++out){
		//cout<<"new run"<<endl;
	for(int i=0;i<n_MainPlanes;i++) {
		for(unsigned int j=0;j<repClusters[i].size();++j){
			singleRepetition* r1=repClusters[i][j];
			//k+1 so it never loops with itself
			for(unsigned int k=j+1;k<repClusters[i].size();++k){
				singleRepetition* r2=repClusters[i][k];
				if(r1->valid && r2->valid){
				if(SameDimensions(r1,r2)){
					if(EdgesAtSameLocation(r1,r2)){
						uniteRep(r1, r2);
						//cout<<"united reps "<<endl;
						}
					}
				}
			}
		}
	}
	}


	//get rid of those with less than minVote
	int MINVOTE = 2;
	for(unsigned int k=0;k<repClusters.size();++k){
		for(unsigned int l=0;l<repClusters[k].size();++l){

			if((repClusters[k][l]->weight)<MINVOTE){
				repClusters[k][l]->valid=false;
			}
		}
	}


	for(int itter=0;itter<2;++itter){
		//loop over all repetitions in clusters
		for(unsigned int k=0;k<repClusters.size();++k){
			for(unsigned int l=0;l<repClusters[k].size();++l){
				singleRepetition*  repA=repClusters[k][l];
				//get another repetition within cluster to compare
				for(unsigned int m=0;m<repClusters[k].size();++m){
					singleRepetition*  repB=repClusters[k][m];

					//do compare and find optimal
					if(repA->valid && repB->valid && m!=l){
					if(doTheyOverLap(repA,repB)){
						if(repA->weight==repB->weight){
							BiggestRepWins(repA, repB);
						}
						else if(repA->weight>repB->weight){
							repB->valid=false;
							//repA->weight+=repB->weight;
						}
						else{
							repA->valid=false;
							//repB->weight+=repA->weight;
							}
						}
					}
				}
			}
		}
	}
	
	//
	Vector3f avgDir={0,0,0};
	float localCounter=0.0;
	//fill avgDir
	for(unsigned int i=0;i<reps.size();++i){
		if(reps[i].valid){
			
			//cout<<"this is the vertical vector of a rep "<<endl;
			singleRepetition repA=reps[i];
			int howLongStart=repA.startPoints_3D.size()-1;
			int topRightInd=reps[i].n_vertLines-1;
		
			Vector3f startPt={reps[i].startPoints_3D[0].X,reps[i].startPoints_3D[0].Y,reps[i].startPoints_3D[0].Z};
			Vector3f endVertPt={reps[i].startPoints_3D[howLongStart].X,reps[i].startPoints_3D[howLongStart].Y,reps[i].startPoints_3D[howLongStart].Z};
			Vector3f endHorPt={reps[i].endPoints_3D[topRightInd].X,reps[i].endPoints_3D[topRightInd].Y,reps[i].endPoints_3D[topRightInd].Z};
			Vector3f distV=endVertPt-startPt;
			Vector3f distH=endHorPt-startPt;

			
			//	cout<<"difference of vertical norms: "<<normDiff<<endl;
			
			Vector3f distVN=distV;
			distVN.normalize();
			Vector3f distHN=distH;
			distHN.normalize();
			float dotProd=distVN.dot(distHN);
			optimalReps.push_back(&reps[i]);
			//only the straight one can vote
			if(dotProd<0.03){
				localCounter=localCounter+1.0;
				avgDir+=distVN;
				
				//cout<<"dot prod "<<dotProd<<endl;
				//reps[i].valid=false;
				}
			else{
			
			}
			//cout<<"x y z: "<<distV[0]<<" "<<distV[1]<<" "<<distV[2]<<endl;
		}
	}
	avgDir=avgDir/(localCounter);///!! normalize does not work here!!!!
	cout<<"this is avg dir "<<endl;
	//cout<<"this is local counter "<<localCounter<<endl;
	cout<<"x y z: "<<avgDir[0]<<" "<<avgDir[1]<<" "<<avgDir[2]<<endl;
	avgDir.normalize();
	verticalDir=avgDir;
	//verticalDir.normalize();

	for(unsigned int k=0;k<optimalReps.size();++k){
		
			int howLongStart=optimalReps[k]->startPoints_3D.size()-1;
			int topRightInd=optimalReps[k]->n_vertLines-1;
		
			Vector3f startPt={optimalReps[k]->startPoints_3D[0].X,optimalReps[k]->startPoints_3D[0].Y,optimalReps[k]->startPoints_3D[0].Z};
			Vector3f endVertPt={optimalReps[k]->startPoints_3D[howLongStart].X,optimalReps[k]->startPoints_3D[howLongStart].Y,optimalReps[k]->startPoints_3D[howLongStart].Z};
			Vector3f endHorPt={optimalReps[k]->endPoints_3D[topRightInd].X,optimalReps[k]->endPoints_3D[topRightInd].Y,optimalReps[k]->endPoints_3D[topRightInd].Z};
			Vector3f distV=endVertPt-startPt;
			Vector3f distH=endHorPt-startPt;

			
			//	cout<<"difference of vertical norms: "<<normDiff<<endl;
			Vector3f distVN=distV;
			distVN.normalize();
			Vector3f distHN=distH;
			distHN.normalize();
			float dotProd=distVN.dot(distHN);
			//only
			float PARAL_TOL=0.03; //tolerance for comparing parallel vectors using their dot product
			if(dotProd<PARAL_TOL){
				//localCounter=localCounter+1.0;
				//avgDir+=distVN;
				
				//cout<<"dot prod "<<dotProd<<endl;
				//reps[i].valid=false;
				}
			else{
				straightenReps(optimalReps[k]);
			}
	}
	
	
	
	//cout<<"this is after normalization"<<avgDir[0]<<" "<<avgDir[1]<<" "<<avgDir[2]<<endl;
    clusteringUsingCorners();
	//go through the reps, those that aren't straight enough will have to be straightend out
}




/*
  only run this function once the overlapping check has been made since 2d info will not be updated
  This Function straightens the repetitions pointed on by *rAusing the common vertical direction
 */
void Rep3D::straightenReps(singleRepetition *rA){
			int howLongs=rA->startPoints_3D.size()-1;
			int vlines=rA->n_vertLines;
			int hlines=rA->n_horLines;
	
			Vector3f startPt={rA->startPoints_3D[0].X,rA->startPoints_3D[0].Y,rA->startPoints_3D[0].Z};
			Vector3f endVertPt={rA->startPoints_3D[howLongs].X,rA->startPoints_3D[howLongs].Y,rA->startPoints_3D[howLongs].Z};
			Vector3f endHor={rA->endPoints_3D[vlines-1].X,rA->endPoints_3D[vlines-1].Y,rA->endPoints_3D[vlines-1].Z};
			Vector3f distV=endVertPt-startPt;
			Vector3f distH=endHor-startPt;
			Vector3f distVN=distV;
			distVN.normalize();
			Vector3f distHN=distH;
			distHN.normalize();
	
			float totHeight;
			float totWidth;
	
			float windowH;
			float windowW;
	
			Vector3f e3;
			Vector3f e2;
			Vector3f bottomLVect;	
			Vector3f topRight;
			//in case of a flipped rep
			if(distVN.dot(verticalDir)<(distHN.dot(verticalDir))){
				
				//cout<<"flipped rep"<<endl;
				//startPt=right top pt
				//everything redefined in flipped featureCoord
			Vector3f LeftTopPt={rA->startPoints_3D[0].X,rA->startPoints_3D[0].Y,rA->startPoints_3D[0].Z};
			Vector3f rightTop={rA->startPoints_3D[howLongs].X,rA->startPoints_3D[howLongs].Y,rA->startPoints_3D[howLongs].Z};	
			Vector3f rightBottom={rA->endPoints_3D[vlines-1].X,rA->endPoints_3D[vlines-1].Y,rA->endPoints_3D[vlines-1].Z};
			distH=rightTop-LeftTopPt;	
				
			totWidth=distH.norm();
			distV=rightTop-rightBottom;	
			totHeight=distV.norm();
			int	vlinesloc=rA->n_horLines;
			int	hlinesloc=rA->n_vertLines;
			 windowH=totHeight/(hlinesloc-1);
			 windowW=totWidth/(vlinesloc-1);
	
			Vector3f e3=distH.cross(distV);
			e3.normalize();
	
			Vector3f e2=verticalDir.cross(e3);
			rightBottom=rightTop+verticalDir*totHeight;
					
			vector<point3d> newstart3d;
			vector<point3d> newend3d;
			e2.normalize();	
				//cout<<"norm :"<<verticalDir.norm()<<endl; 
			for(int i=0;i<hlinesloc;++i){
				point3d lcStartpts;
				Vector3f startCoords=rightTop+i*verticalDir*windowH;
				lcStartpts.ID_3D=0;
				lcStartpts.X=startCoords[0];
				lcStartpts.Y=startCoords[1];
				lcStartpts.Z=startCoords[2];
				newstart3d.push_back(lcStartpts);
			
				point3d lcEndpts;
				Vector3f endCoords=LeftTopPt+i*windowH*verticalDir;
				lcEndpts.ID_3D=0;
				lcEndpts.X=endCoords[0];
				lcEndpts.Y=endCoords[1];
				lcEndpts.Z=endCoords[2];
				newend3d.push_back(lcEndpts);
			}
			//vertically
			for(int j=hlinesloc;j<hlinesloc+vlinesloc;++j){
			
				point3d lcStartpts;
				Vector3f startCoords=rightTop+(j-hlinesloc)*e2*windowW;
				lcStartpts.ID_3D=0;
				lcStartpts.X=startCoords[0];
				lcStartpts.Y=startCoords[1];
				lcStartpts.Z=startCoords[2];
				newstart3d.push_back(lcStartpts);
			
				point3d lcEndpts;
				Vector3f endCoords=rightBottom+(j-hlinesloc)*e2*windowW;
				lcEndpts.ID_3D=0;
				lcEndpts.X=endCoords[0];
				lcEndpts.Y=endCoords[1];
				lcEndpts.Z=endCoords[2];
				newend3d.push_back(lcEndpts);
			}
			
			rA->startPoints_3D=newstart3d;
			rA->endPoints_3D=newend3d;
				//rA->valid=false;
			}
			//whenever rep isn't flipped
			else{
			 totHeight=distV.norm();
			 totWidth=distH.norm();
	
			 windowH=totHeight/(hlines-1);
			 windowW=totWidth/(vlines-1);
	
			 e3=distV.cross(distH);
			e3.normalize();
	
			 e2=e3.cross(verticalDir);
			 bottomLVect=startPt+totHeight*verticalDir;	
			 topRight=startPt+totWidth*e2;
						
			vector<point3d> newstart3d;
			vector<point3d> newend3d;
	
			for(int i=0;i<vlines;++i){
				point3d lcStartpts;
				Vector3f startCoords=startPt+i*e2*windowW;
				lcStartpts.ID_3D=0;
				lcStartpts.X=startCoords[0];
				lcStartpts.Y=startCoords[1];
				lcStartpts.Z=startCoords[2];
				newstart3d.push_back(lcStartpts);
			
				point3d lcEndpts;
				Vector3f endCoords=bottomLVect+i*windowW*e2;
				lcEndpts.ID_3D=0;
				lcEndpts.X=endCoords[0];
				lcEndpts.Y=endCoords[1];
				lcEndpts.Z=endCoords[2];
				newend3d.push_back(lcEndpts);
			}
			//vertically
			for(int j=vlines;j<hlines+vlines;++j){
			
				point3d lcStartpts;
				Vector3f startCoords=startPt+(j-vlines)*verticalDir*windowH;
				lcStartpts.ID_3D=0;
				lcStartpts.X=startCoords[0];
				lcStartpts.Y=startCoords[1];
				lcStartpts.Z=startCoords[2];
				newstart3d.push_back(lcStartpts);
			
				point3d lcEndpts;
				Vector3f endCoords=topRight+(j-vlines)*verticalDir*windowH;
				lcEndpts.ID_3D=0;
				lcEndpts.X=endCoords[0];
				lcEndpts.Y=endCoords[1];
				lcEndpts.Z=endCoords[2];
				newend3d.push_back(lcEndpts);
			}
				
			rA->startPoints_3D=newstart3d;
			rA->endPoints_3D=newend3d;	
	
			}

}

/*
  uses absolut distance of all 4 corners of a repetition to another repetitions and DBSCAN to find
  repetitions belonging together
  used in the end as further cleansing step
 */
void Rep3D::clusteringUsingCorners(){


    // LUKAS IMPLEMENTATION -> should be a separate function in the tools
    //give accurate name lookForComonDist()?
    //for (int i = 0; i < n_MainPlanes; i++) {
    vector<singleRepetition *> tempRepPtrs;
    deque<singleRepetition *> tempCluster;
    deque<deque<singleRepetition *>> toBeInspected;
    // get reps on this plane
    for(unsigned int j=0;j<optimalReps.size();++j){
        tempRepPtrs.push_back(optimalReps[j]);
    }

    cout<<"size optimal reps "<<optimalReps.size()<<endl;
    MatrixXf distMat(tempRepPtrs.size(), tempRepPtrs.size());
    // calculate distance matrix
    for (unsigned int j = 0; j < tempRepPtrs.size(); j++) {
        for (unsigned int q = 0; q < tempRepPtrs.size(); q++) {
            //loop over corners
            float xdif=0;
            float ydif=0;
            for(int cornerIdx=0;cornerIdx<4;cornerIdx++) {
                xdif = xdif+abs(tempRepPtrs[j]->cornerAlphaBeta[cornerIdx].first-tempRepPtrs[q]->cornerAlphaBeta[cornerIdx].first);
                ydif = ydif+abs(tempRepPtrs[j]->cornerAlphaBeta[cornerIdx].second-tempRepPtrs[q]->cornerAlphaBeta[cornerIdx].second);
            }
            distMat(j,q) = xdif+ydif;

            vector<float> diff;

            for (int cornerIdx = 0; cornerIdx < 4; cornerIdx++) {
                diff.push_back(abs(tempRepPtrs[j]->cornerAlphaBeta[cornerIdx].first -
                                   tempRepPtrs[q]->cornerAlphaBeta[cornerIdx].first) +
                               abs(tempRepPtrs[j]->cornerAlphaBeta[cornerIdx].second -
                                   tempRepPtrs[q]->cornerAlphaBeta[cornerIdx].second));

            }

            distMat(j, q) = min(diff);

        }
    }
    //clusteringydiff
    // eps=0.02 and min_elems=5 pretty good but kills a lot
    // eps=0.01 and min_elems=4 best
    float eps = 0.1;
    int min_elems = 1;
    clustering::DBSCAN<VectorXf, MatrixXf> cloud(eps, min_elems);
    cloud.fit(distMat);
    vector<int> Labels = cloud.get_labels();
    int n_clusters = max<int>(Labels) + 1;
    cout<<"amount of clusters "<<n_clusters<<endl;
    //assign clusters to used data structure

    for (int labelNr = 0; labelNr < n_clusters; labelNr++) {
        tempCluster.clear();
        //cout<<"this is labelNr"<<labelNr<<endl;

        for (unsigned int repIdx = 0; repIdx < tempRepPtrs.size(); repIdx++) {
            if (Labels[repIdx] == labelNr) {
                tempCluster.push_back(tempRepPtrs[repIdx]);
            }

        }
        //cout<<"local size "<<tempCluster.size()<<endl;
        if(tempCluster.size()>1){
            for(unsigned int k=1;k<tempCluster.size();++k){
                if(tempCluster[k]->planeptr!=tempCluster[0]->planeptr){
                    tempCluster[k]->valid=false;
                }
            }

        }

    }
}

/*
  checks if the two reps have similar x y cell dimensions
 */
bool Rep3D::SameDimensions(singleRepetition* rA, singleRepetition* rB){
	bool SimilarDim=false;
	float TOLDIN3D=0.06;//tolerance
	if(rA->valid && rB->valid){
	vector <float> theXDAvg;		//average x dist
	vector <float> theYDAvg;		//average y dist
	deque <singleRepetition*> localClust={rA,rB};
	
	//get the x and y average size of a rep cell
	for(int j=0;j<2;++j){
			vector <float> avgX;
			vector <float> avgY;
			int hcells=localClust[j]->n_vertLines;
			int vcells=localClust[j]->n_horLines;

			//information gatherd in 3D to avoid any imperfections with e1 e2 orthogonality
			for(int k=1;k<vcells;++k){
				point3d ptA=localClust[j]->startPoints_3D[k];
				point3d ptB=localClust[j]->startPoints_3D[k-1];
				avgX.push_back(point3dNorm(ptA,ptB));
			}
			//int sizeBckwrds=repClusters[i][j]->endPoints_3D.size();
			//vcells +1 in order to skip the doubly stored left top corner
			for(int l=vcells+1;l<1+vcells+hcells;++l){
				point3d ptA1=localClust[j]->startPoints_3D[l];
				point3d ptB1=localClust[j]->startPoints_3D[l-1];
				avgY.push_back(point3dNorm(ptA1,ptB1));
			}
			theXDAvg.push_back(mean(avgX));
			theYDAvg.push_back(mean(avgY));
			
		}//end of j for loop
	
	//check if the cell size is comparable in both directions
		if(abs(theXDAvg[0]-theXDAvg[1])<TOLDIN3D){
			if(abs(theYDAvg[0]-theYDAvg[1])<TOLDIN3D){
				SimilarDim=true;
			}
		}	
	}//end if statement checking validity
	return SimilarDim;
}


/*
  checks if edges are at same location
  should only be called on two reps that passed the SameDimensions Test
 */
bool Rep3D::EdgesAtSameLocation(singleRepetition* rA, singleRepetition* rB){
		bool yesWeCan=false;
		float TOL=0.06;
		int vlinesA=rA->n_vertLines;
		int vlinesB=rB->n_vertLines;
		//int hlinesA=rA->n_horLines;
		//int hlinesB=rB->n_horLines;
		//int stopI=startPoints_3D[].size();
		for(int i=0;i<vlinesA;++i){
			for(int j=0;j<vlinesB;++j){
				float toTest=point3dNorm(rA->startPoints_3D[i],rB->startPoints_3D[j]);
				if(toTest<TOL){
					i=vlinesA;
					j=vlinesB;
					yesWeCan=true;
				}
			}
		}
		return yesWeCan;
} 

/*
  should only be called on reps that have passed EdgesAtSameLocation and SameDimensions
  will cancel rB and put result into rA
  does more than just voting, also unites reps!!!
 */
void Rep3D::uniteRep(singleRepetition *rA, singleRepetition *rB){
	float TOL=0.06;//distance between 2 points in 3D
	if(rA->valid && rB->valid){
	int vlinesA=rA->n_vertLines;
	int vlinesB=rB->n_vertLines;
	int hlinesA=rA->n_horLines;
	int hlinesB=rB->n_horLines;
	point3d startingPoint;
	point3d topRight;
	point3d bottomRight;
	point3d bottomLeft;
	//find match index
	pair<int,int> matchInd;
	for(int i=0;i<vlinesA;++i){
			for(int j=0;j<vlinesB;++j){
				float toTest=point3dNorm(rA->startPoints_3D[i],rB->startPoints_3D[j]);
				if(toTest<TOL){
					matchInd.first=i;
					matchInd.second=j;
				}
			}
		}
	
	if(vlinesA==vlinesB && hlinesA==hlinesB && matchInd.first==0 && matchInd.second==0){
		//perfect match
		rB->valid=false;
		rB->planeptr=nullptr;
		rA->weight+=rB->weight;
		
	}
		//the biggest wins
	else if(matchInd.first==0 && matchInd.second==0 && hlinesA==hlinesB){
		

		if(vlinesA>vlinesB){
		rA->valid=false;
		rA->planeptr=nullptr;
		rB->weight+=rA->weight;	
		}
		else{
		rB->valid=false;
		rB->planeptr=nullptr;
		rA->weight+=rB->weight;
		}
	}	
		
	//not a perfect match,but same amount of hlines
	else if(hlinesA==hlinesB)
	{
		vector<pair<float,float>> local2DCorner;
		int toAdd=0;
		if(matchInd.second<matchInd.first){
			startingPoint=rA->startPoints_3D[0];
			local2DCorner.push_back(rA->cornerAlphaBeta[0]);
			topRight=rB->startPoints_3D[vlinesB-1];//
			local2DCorner.push_back(rB->cornerAlphaBeta[1]);
			bottomRight=rB->endPoints_3D[vlinesB-1];//check
			local2DCorner.push_back(rB->cornerAlphaBeta[2]);
			int endMe=rA->startPoints_3D.size()-1;
			local2DCorner.push_back(rA->cornerAlphaBeta[3]);
			bottomLeft=rA->startPoints_3D[endMe]; //check
			toAdd=abs(matchInd.first-matchInd.second)+vlinesB; //check
		}	
		else{
			startingPoint=rB->startPoints_3D[0];
			local2DCorner.push_back(rB->cornerAlphaBeta[0]);
			topRight=rA->startPoints_3D[vlinesA-1];
			local2DCorner.push_back(rA->cornerAlphaBeta[1]);
			bottomRight=rA->endPoints_3D[vlinesA-1];
			local2DCorner.push_back(rA->cornerAlphaBeta[2]);
			int endMe=rB->startPoints_3D.size()-1;
			local2DCorner.push_back(rB->cornerAlphaBeta[3]);
			bottomLeft=rB->startPoints_3D[endMe];
			toAdd=abs(matchInd.first-matchInd.second)+vlinesA;
		}
		//find main direction and redifne the rep
		Vector3f main_e1={-startingPoint.X+topRight.X,-startingPoint.Y+topRight.Y,-startingPoint.Z+topRight.Z};
		float e1n=main_e1.norm();
		main_e1.normalize();
		e1n=e1n/(toAdd-1.f);
		Vector3f main_e2={-startingPoint.X+bottomLeft.X,-startingPoint.Y+bottomLeft.Y,-startingPoint.Z+bottomLeft.Z};
		float e2n=main_e2.norm();
		main_e2.normalize();
		e2n=e2n/(hlinesA-1);
		//how much in every direction?
		Vector3f startVect={startingPoint.X,startingPoint.Y,startingPoint.Z};
		Vector3f bottomLVect={bottomLeft.X,bottomLeft.Y,bottomLeft.Z};
	//	Vector3f bottomRVect={bottomRight.X,bottomRight.Y,bottomRight.Z};
		Vector3f topRightVect={topRight.X,topRight.Y,topRight.Z};
		vector<point3d> newstart3d;
		vector<point3d> newend3d;
		//horizontally
		for(int i=0;i<toAdd;++i){
			point3d lcStartpts;
			Vector3f startCoords=startVect+i*main_e1*e1n;
			lcStartpts.ID_3D=0;
			lcStartpts.X=startCoords[0];
			lcStartpts.Y=startCoords[1];
			lcStartpts.Z=startCoords[2];
			newstart3d.push_back(lcStartpts);
			
			point3d lcEndpts;
			Vector3f endCoords=bottomLVect+i*main_e1*e1n;
			lcEndpts.ID_3D=0;
			lcEndpts.X=endCoords[0];
			lcEndpts.Y=endCoords[1];
			lcEndpts.Z=endCoords[2];
			newend3d.push_back(lcEndpts);
			
		}
		//vertically
		for(int j=toAdd;j<toAdd+hlinesA;++j){
			
			point3d lcStartpts;
			Vector3f startCoords=startVect+(j-toAdd)*e2n*main_e2;
			lcStartpts.ID_3D=0;
			lcStartpts.X=startCoords[0];
			lcStartpts.Y=startCoords[1];
			lcStartpts.Z=startCoords[2];
			newstart3d.push_back(lcStartpts);
			
			point3d lcEndpts;
			Vector3f endCoords=topRightVect+(j-toAdd)*e2n*main_e2;
			lcEndpts.ID_3D=0;
			lcEndpts.X=endCoords[0];
			lcEndpts.Y=endCoords[1];
			lcEndpts.Z=endCoords[2];
			newend3d.push_back(lcEndpts);
			
		}
		//trun of b replace a with new data
		rB->valid=false;
		rB->planeptr=nullptr;
		rA->weight+=rB->weight;
		//cout<<"new weight of a"<<rA->weight<<endl;
		rA->n_vertLines=toAdd;
		rA->startPoints_3D=newstart3d;
		rA->endPoints_3D=newend3d;
		rA->cornerAlphaBeta=local2DCorner;
		
	}
	//very different strucutre-> reconstruc the rep fully
	else{
		//try to increase their weight
		rA->weight+=1;
		rB->weight+=1;
	}
	}
}

/*
if two repetitions compete at final stage and have same weights, take the one with the biggest area
 */
void Rep3D::BiggestRepWins(singleRepetition *rA, singleRepetition *rB){
	///a-----b
	///-------
	///c-----d d not used
	
	//find the biggest area
	float aX=rA->cornerAlphaBeta[0].first;
	float bX=rA->cornerAlphaBeta[1].first;
	float cX=rA->cornerAlphaBeta[3].first;
	float aY=rA->cornerAlphaBeta[0].second;
	float bY=rA->cornerAlphaBeta[1].second;
	float cY=rA->cornerAlphaBeta[3].second;
	float side1=sqrt((aX-bX)*(aX-bX)+(aY-bY)*(aY-bY));
	float side2=sqrt((aX-cX)*(aX-cX)+(aY-cY)*(aY-cY));
	float compA=side1*side2;
	
	 aX=rB->cornerAlphaBeta[0].first;
	 bX=rB->cornerAlphaBeta[1].first;
	 cX=rB->cornerAlphaBeta[3].first;
	 aY=rB->cornerAlphaBeta[0].second;
	 bY=rB->cornerAlphaBeta[1].second;
	 cY=rB->cornerAlphaBeta[3].second;
	 float side11=sqrt((aX-bX)*(aX-bX)+(aY-bY)*(aY-bY));
	 float side21=sqrt((aX-cX)*(aX-cX)+(aY-cY)*(aY-cY));
	 float compB=side11*side21;
	//biggest area
	if(compB>compA){
		rA->valid=false;
		//increment weight of surviving rep?
	}
	else{
		rB->valid=false;
	}
}

/*
  checks if two repetitions overlap
 */
bool Rep3D::doTheyOverLap(singleRepetition* rA,singleRepetition* rB ){
	bool overlp=false;
	//using the in polygon method in order to avoid problems wiht non orthogonal e1 e2
	float polyXa[4];
	float polyXb[4];
	float polyYa[4];
	float polyYb[4];
	pair<float,float> middleA;
	pair<float,float> middleB;
	for(int i=0;i<4;++i){
		polyXa[i]=rA->cornerAlphaBeta[i].first;
		middleA.first+=rA->cornerAlphaBeta[i].first/4.f;
		polyYa[i]=rA->cornerAlphaBeta[i].second;
		middleA.second+=rA->cornerAlphaBeta[i].second/4.f;
		polyXb[i]=rB->cornerAlphaBeta[i].first;
		middleB.first+=rB->cornerAlphaBeta[i].first/4.f;
		polyYb[i]=rB->cornerAlphaBeta[i].second;
		middleB.second+=rB->cornerAlphaBeta[i].second/4.f;
	}
	//check if edges of a are in b
	for(int j=0;j<4;++j){
		if(inPolygon(polyXa, polyYa,polyXb[j],polyYb[j],4)){
			overlp=true;
			break;
		}
	}
	if(inPolygon(polyXa, polyYa,middleB.first,middleB.second,4)){
			overlp=true;
		}
	//check if edges of b are in a
	if(!overlp){
		for(int k=0;k<4;++k){
		if(inPolygon(polyXb, polyYb,polyXa[k],polyYa[k],4)){
			overlp=true;
			break;
		}
		}
	}
	if(inPolygon(polyXb, polyYb,middleA.first,middleA.second,4)){
			overlp=true;
		}
	return overlp;
}


///---------TOOLS 

/*
 checks if a projection plane is used by any rep
 */
bool Rep3D::plane_is_valid(plane E)
{
	bool result=false;
	int n_dependent_reps=E.rep_ptr.size();
	for(int i=0;i<n_dependent_reps;i++)
	{
		result=result||(E.rep_ptr[i]->valid);
		if(result==true)
		{
			break;
		}
	}
	return result;
}

/*
  helper to calculate the norm of the distance between two 3D points
 */
float Rep3D::point3dNorm(point3d ptA, point3d ptB){
	Vector3f v1= {ptA.X-ptB.X,ptA.Y-ptB.Y,ptA.Z-ptB.Z};
	return v1.norm();
}

/*
  helper function to get all the lines of a repetition in 3D
 */
void Rep3D::get_3D_rep_lines(vector<vector<float> > &startpkt, vector<vector<float> > &endpkt)
{
    vector<float> element(3);				//[X,Y,Z] element of the vector of 3D points
    vector<float> element2(3);


    //#pragma omp parallel for
    for(unsigned int i=0;i<reps.size();i++)															//for every rep
    {
        if(reps[i].valid==true)
        {
            int n_rep_lines=reps[i].startPoints_3D.size();
            for(int k=0;k<n_rep_lines; k++)											//for every rep line
            {
                element[0]=reps[i].startPoints_3D[k].X;
                element[1]=reps[i].startPoints_3D[k].Y;
                element[2]=reps[i].startPoints_3D[k].Z;
                //startpkt.push_back(element);

                element2[0]=reps[i].endPoints_3D[k].X;
                element2[1]=reps[i].endPoints_3D[k].Y;
                element2[2]=reps[i].endPoints_3D[k].Z;
                //endpkt.push_back(element);

                Vector3f toApplyTest={element[0]-element2[0],element[1]-element2[1],element[2]-element2[2]};
                float testLimit=toApplyTest.norm();
                //should probably get rid of this?? only usefull when inefficient cleanup function is used
                float chosenLimit=30.f;
                if(testLimit<chosenLimit){
                    endpkt.push_back(element2);
                    startpkt.push_back(element);
                }
            }
        }
    }
}

///------- OUTPUT FUNCTIONS
/*
  writer function to write a vrml file
 */
void Rep3D::print_VRML(string filename)
{
	clock_t timer = time(0);
	cout<<endl<<"Print "<<filename<<"..."<<endl;

	writeColmapPointsToVRML(filename);
	writeRepLinesToVRML(filename);

	float t =difftime( time(0), timer);
	cout<<endl<<"print_VRML done! ["<<t<<" sec]"<<endl;
}

/*
  writes colmap 3D points to a VRML file
 */
void Rep3D::writeColmapPointsToVRML(string filename)
{
	MatrixXf points	= get_3D_data();
		MatrixXf points_3D=points.middleCols<3>(1);		// we dont need the ID's

		//define Color;
		int color[3]={255,0,255};

		//convert eigen::points_3D to vector::data (typecast)
		vector<vector<float> > data(n_3Dpoints, vector<float>(3));

		for(int i=0;i<3;i++)
		{
			for(int j=0;j<n_3Dpoints;j++)
			{
				data[j][i]=points_3D(j,i);
			}
		}
	    writePointsToVRML(data,color,filename.c_str(), false);
}

/*
  writes all start and end points of all the lines of all repetitions to a VRML file
 */
void Rep3D::writeRepLinesToVRML(string filename)
{

	vector<vector<float> > startpkt;
	vector<vector<float> > endpkt;

	get_3D_rep_lines(startpkt,endpkt);		//search for all lines which should be drawn

	writeLinesToVRML(startpkt,endpkt,filename,true);
	
}

/*
  write 3D cloud points to a csv file
 */
void Rep3D::writeCloudToCSV(string filename) {

	ofstream cloudFile;
	cloudFile.open (filename);
	//header
	cloudFile << "ID" <<","<<"X"<<","<<"Y"<<","<<"Z"<<"\n";

	for(unsigned int i=0;i<pointCloud.size();i++)
	{
		cloudFile << pointCloud[i].ID_3D<< "," << pointCloud[i].X << ","
				  << pointCloud[i].Y << "," << pointCloud[i].Z<<"\n";
	}

	cloudFile.close();

}

/*
  writes found clusters to csv file
 */
void Rep3D::writeClustersToCSV(string filename) {

	ofstream clusterFile;
	clusterFile.open(filename);
	//header
	clusterFile << "ClusterID" << "," << "X" << "," << "Y" << "," << "Z" << "\n";

	for (unsigned int i = 0; i < repClusters.size(); i++) {
		for (unsigned int j = 0; j < repClusters[i].size(); j++){
			for(unsigned int q=0; q < repClusters[i][j]->startPoints_3D.size();q++){
				//if(repClusters[i][j]->valid) {
					clusterFile << i << "," <<
								repClusters[i][j]->startPoints_3D[q].X << "," <<
								repClusters[i][j]->startPoints_3D[q].Y << "," <<
								repClusters[i][j]->startPoints_3D[q].Z << "," <<
								repClusters[i][j]->endPoints_3D[q].X << "," <<
								repClusters[i][j]->endPoints_3D[q].Y << "," <<
								repClusters[i][j]->endPoints_3D[q].Z << "\n";

				//}
				}
		}
	}
	clusterFile.close();
}
/*
 write raw projections of repetitions (before hough transform cleansing) to csv file
 */
void Rep3D::writeRawProjRepsToCSV(string filename) {

	ofstream file;
	file.open(filename);
	//header
	file << "RepID" << "," << "X" << "," << "Y" << "," << "Z" << "\n";

	for (unsigned int i = 0; i < reps.size();i++){
		for(unsigned int q=0; q < reps[i].startPoints_3D.size();q++){
			if(reps[i].valid){
			file << reps[i].repID << "," <<
				 reps[i].startPoints_3D[q].X << "," <<
				 reps[i].startPoints_3D[q].Y << "," <<
				 reps[i].startPoints_3D[q].Z << "," <<
				 reps[i].endPoints_3D[q].X << "," <<
				 reps[i].endPoints_3D[q].Y << "," <<
				 reps[i].endPoints_3D[q].Z << "\n";
			}
		}
	}
}

/*
  used to display plot after processing data
 */
void Rep3D::show_plot()
{
  system("python vis.py");
}

Rep3D::~Rep3D(){};
//test and unused functions below
/*	 //unused cleanup function, hough transform works (much) better
cleanupRep(){
    float tolAlpha=0.94;
    int stopAgain=theGoodOnes.size();
    vector<int> bigCounter;
    vector<Vector3f> mainDirections;
    cout<<"amount of good vectors "<<stopAgain<<endl;
    //clusterize the good vectors,ie those that have not been filtered out previously
    //votes are cast into bigcounter, directions into mainDirections
    //initialize the counter
    bigCounter.push_back(1);
    mainDirections.push_back(theGoodOnes[0]);
    for(int k=1;k<stopAgain;++k){
        int itter=mainDirections.size();
        for(int j=0;j<itter;++j){
            if((mainDirections[j].dot(theGoodOnes[k]))>tolAlpha){
                Vector3f toMod=bigCounter[j]*mainDirections[j]+theGoodOnes[k];
                //cout<<"before "<<mainDirections[j][0]<<" "<<mainDirections[j][1]<<endl;
                toMod.normalize();
                mainDirections[j]=toMod;
                //cout<<"after "<<toMod[0]<<" "<<toMod[1]<<endl;

                bigCounter[j]=bigCounter[j]+1;
                j=itter;//important!!
            }
                //create a new entry into theGoodOnes
            else if(j==(itter-1) && (mainDirections[j].dot(theGoodOnes[k]))<=tolAlpha){
                //cout<<"main directions bla bla"<<(mainDirections[j].dot(theGoodOnes[k]))<<endl;
                bigCounter.push_back(1);
                mainDirections.push_back(theGoodOnes[k]);
            }
        }
    }

    cout<<"amount of main directions: "<<mainDirections.size()<<endl;
    //determine the 2 biggest directions -> find 1 and 2nd maxima
    int max1=0,max2=0;
    if(bigCounter.size()>1){
        cout<<"inside"<<endl;
        int actualMax=bigCounter[bigCounter.size()-1];
        int actualMax2=bigCounter[bigCounter.size()-1];
        for (int i=(bigCounter.size()-1);i>-1;--i){
            if(bigCounter[i]>actualMax){
                actualMax2=actualMax;
                actualMax=bigCounter[i];
                max2=max1;
                max1=i;
            }
            else if(bigCounter[i]>actualMax2){
                actualMax2=bigCounter[i];
                max2=i;
            }
            cout<<"line: "<<bigCounter[i]<<endl;
        }
        cout<<"biggest direction 1: "<<max1<<endl;
        cout<<"biggest direction 2: "<<max2<<endl;
    }
    else{
        cout<<"biggest direction 1: "<<max1<<endl;
        cout<<"biggest direction 2: "<<max2<<endl;
    }
    //filter through the planes and eliminate the outliers
    //!!this assmes order is the same on reps and planes deques!!
    //will eliminate wrong lines if this is not the case
    Vector3f mainDirection1=mainDirections[max1];
    Vector3f mainDirection2=mainDirections[max2];
    float alpha2=0.99;
    for(int j1=0;j1<stopMeReps;++j1){
        if((planes[j1].ne3.cwiseAbs().dot(mainDirection1)<alpha2) && (planes[j1].ne3.cwiseAbs().dot(mainDirection2)<alpha2) ){
            //cout<<"hello"<<endl;
            //get the pointer
            planes[j1].repptr[0]->valid=false;
        }
        //if e1 dot e2 >0.5 -> problem, set to noPrint
		Vector3f norme1=planes[j1].e1;//.normalize();
		Vector3f norme2=planes[j1].e2;//.normalize();
		norme1.normalize();
		norme2.normalize();
        if((norme1.dot(norme2))>0.5){
            planes[j1].repptr[0]->valid=false;
        }
    }

	float t =difftime( time(0), timer);
	cout<<"cleanUp Outlier Planes done! ["<<t<<" sec]"<<endl;
}
*/
/*
//not used anymore!!!!!!
void Rep3D::optimizeRepClusters(){
	
	cout<<"starting cluster optimization "<<endl;
	int cluSize=repClusters.size();
	cout<<"this is cluSize: "<<cluSize<<endl;
	for(int i=0;i<cluSize;++i){
	
		int locSize=repClusters[i].size();
		vector <float> theXDAvg;		//average x dist
		vector <float> theYDAvg;		//average y dist

			cout<<"----new cluster, size: "<<locSize<<endl;
		bool diffSize=false;
		
		for(int j=0;j<locSize;++j){
			vector <float> avgX;
			vector <float> avgY;
			int hcells=repClusters[i][j]->n_vertLines;
			int vcells=repClusters[i][j]->n_horLines;
			cout<<" this is the hcells and vcels "<<hcells<<" "<<vcells<<endl;	

			//information gatherd in 3D to avoid any imperfections with e1 e2 orthogonality
			for(int k=1;k<vcells;++k){
				point3d ptA=repClusters[i][j]->startPoints_3D[k];
				point3d ptB=repClusters[i][j]->startPoints_3D[k-1];
				avgX.push_back(point3dNorm(ptA,ptB));
			}
			//int sizeBckwrds=repClusters[i][j]->endPoints_3D.size();
			//vcells +1 in order to skip the doubly stored left top corner
			for(int l=vcells+1;l<1+vcells+hcells;++l){
				point3d ptA1=repClusters[i][j]->startPoints_3D[l];
				point3d ptB1=repClusters[i][j]->startPoints_3D[l-1];
				avgY.push_back(point3dNorm(ptA1,ptB1));
			}
			theXDAvg.push_back(mean(avgX));
			theYDAvg.push_back(mean(avgY));
			
		}//end of j for loop
		
		MatrixXf distroMat(locSize,locSize);
		float tol=0.1;
		int min_el=int(locSize*.4);
		for(int ko=0;ko<locSize;++ko){
			for(int kl=0;kl<locSize;++kl){
				distroMat(ko,kl)=theXDAvg[ko]-theXDAvg[kl]+theYDAvg[ko]-theYDAvg[kl];
			}
		}
		//find the most common avgx,avgy value	
		
		clustering::DBSCAN<VectorXf, MatrixXf> cloud(tol, min_el);
		cloud.fit(distroMat);
		vector<int> Labels = cloud.get_labels();
		
		int n_clusters=max<int>(Labels)+1;
		
		cout<<"----this is amount of local clusters "<<n_clusters<<endl;
		cout<<"min elements "<<min_el<<endl;
		//only if the there is more than one cluster
		if(n_clusters>1){
			//find indexes of max clusters
			int cntr=0; //how many times the most common elements exists
			int loc=0;  //which one it is
			for(int ct=0;ct<n_clusters;++ct){
				int ncntr=0;
				for(int v=0;v<locSize;++v){
					if(Labels[v]==ct){
						ncntr++;
					}
				}
				if(ncntr>cntr){
				loc=ct;
				cntr=ncntr;	
				}
			}
			//get the big elements
			vector<int> usefullInd;
			for(int m=0;m<locSize;++m){
				if(Labels[m]==loc){
					usefullInd.push_back(m);
				}
			}
			deque <singleRepetition*> toKeep;
			//redefine the reps	
			//set reps to false
			for(int m=0;m<locSize;++m){
				if ((find(usefullInd.begin(), usefullInd.end(), m) != usefullInd.end())==false){
					repClusters[i][m]->planeptr=nullptr;
					repClusters[i][m]->valid=false;
				}
				else{
					toKeep.push_back(repClusters[i][m]);
				}
			}
			//overwrite the pointer
			repClusters[i]=toKeep;
		}//end if n_clusters>1
		
		//check if the top left pnts intersect
		//important
		locSize=repClusters[i].size();
		float toll=0.01;
		int maxVlin=0;
		int maxHlin=0;
		for(int m=0;m<locSize;++m){
			int localStop=repClusters[i][m]->startPoints_3D.size();
			point3d ptA=repClusters[i][m]->startPoints_3D[0];
			maxVlin=repClusters[i][m]->n_vertLines;
			maxHlin=repClusters[i][m]->n_vertLines;
			//start at m1=m in order to avoid doubles
			for(int m1=m;m1<localStop;++m1){
				//don't compare with itself
				if(m1!=m){
					point3d ptB=repClusters[i][m]->startPoints_3D[m1];
					if(point3dNorm(ptA,ptB)<toll){
						cout<<"yes we can!"<<endl;
						//combine reps
						//test passed
						//m1=localStop;
					}
				}
			}
		}
		
		//get the biggest reps associated to 
		//for(int m=0;m<locSize;++m){
		//	cout<<"average X: "<<theXDAvg[m]<<endl;
			//cout<<"average Y: "<<theYDAvg[m]<<endl;
			//cout<<"oneoverother: "<<theXDAvg[m]/theYDAvg[m]<<endl;
		//}
	}
}*/
/*



 */



/*void Rep3D::clusterReps()
{
	cout<<"Clustering repetitions now..."<<endl;
	// grab the last planes inserted into planes = nrOfMainPlanes
	//they are the only ones
	//using deque for safety (ptrs)
	deque<plane> mainPlanes;//
	deque<deque<singleRepetition*>> associatedReps;//
	int sizeOfPl=planes.size()-1;//-1 since a vector with one element is at index 0!
	int amReps=reps.size();
	//loop through the added planes and see which reps are associated to them
	for(int i=0;i<nrOfMainPlanes;++i){
		mainPlanes.push_back(planes[sizeOfPl-i]);
		plane *locPl=&planes[sizeOfPl-i];
			deque<singleRepetition*>localReps;
			for(int j=0;j<amReps;++j){
				//if thy point to the same plane
			if(locPl==reps[j].planeptr){
				if(reps[j].valid){
					localReps.push_back(&reps[j]);
				}
				else{
				cout<<" problem: found it"<<endl;
				}
			}
		}
		associatedReps.push_back(localReps);
	}
	
	deque<singleRepetition*> repsPtr; //used to pop away reps belonging to clusters
    deque<singleRepetition*> tempCluster; //used as temporay cluster storage, added to clusters vector after iteration
    bool pushBackCluster; //if true, temp cluster will be added to clusters vector after iteration
	*//*
	for(int i=0;i<nrOfMainPlanes;++i){
		int stopMe=associatedReps[i].size();
		cout<<"this is stopMe "<<stopMe<<endl;
		for(int j=0;j<stopMe;++j){
			cout<<"name of local rep in cluster "<<associatedReps[i][j]->repID<<endl;
		}
	}
	*//*
	//loop over the local elements in associatedReps[i] and try to match them as best as one can
	
	for(int i=0;i<nrOfMainPlanes;++i){
		//planes[planes.size()-i];
		int stopMe=associatedReps[i].size();
		cout<<"this is stopMe "<<stopMe<<endl;
		//deque localRepQue=associatedReps[i];
		//should not need to check if reps are valid, they would already have been weeded out before
		
		for(int k=0;k<stopMe;++k){
			tempCluster.clear(); //clear the temporary vector
			tempCluster.push_back(associatedReps[i][k]); //initialize with current repetition
			pushBackCluster = false; //do not push temporary back unless in next loop a cluster is found where it belongs to
			repsPtr=associatedReps[i];
			int j = 0;
			while (j < repsPtr.size())
				//note while is not problem, since there is always overlapps wiht itself for each rep, will end eventually and break out of the while loop
			{
				//maybee use for k??
				//				for l
				//					if l!=k...
				//TODO here corners are from 3Dreps but will need the projection of those on the mainplane, need to adjust later, this is only for testing
			
				//TODO might want to introduce corners3D and corners3Dproj...
				//DONE by Tim used the cornerAlphaBeta instead of 3d info
				//this is the main criteria for overlapping rectangles
				//note that repsPtr changes size since entries that are found in clusters are erased
				//P1010435.JPG_repNr_1 is problematic for some reason
				int testtoprint=reps[i].cornerAlphaBeta.size();
			//	cout<<"size of testtoprint 4??: "<<testtoprint<<endl;
				
				if (associatedReps[i][k]->cornerAlphaBeta[0].first < repsPtr[j]->cornerAlphaBeta[1].first && 
					associatedReps[i][k]->cornerAlphaBeta[1].first > repsPtr[j]->cornerAlphaBeta[0].first &&
					associatedReps[i][k]->cornerAlphaBeta[0].second > repsPtr[j]->cornerAlphaBeta[2].second &&
					associatedReps[i][k]->cornerAlphaBeta[2].second < repsPtr[j]->cornerAlphaBeta[0].second) {
					//add pointer to the rep to the temp cluster
					tempCluster.push_back(repsPtr[j]);
					//erase the current pointer form the repsPtr vector
					repsPtr.erase(repsPtr.begin() + j);
					//set pushbackCluster equal to ture in order to later on be written into clusters vector
					pushBackCluster = true;

					//TODO might need to introduce a min % of overlapping, to reject bad overlaps but probaly not necessary due to character of repetition data
					}
				else {
					//only increase j if there was nothing removed form the repsPtr
					j++;
				}
			
			}
			
			if (pushBackCluster) {
				//remove first entry of temp cluster since intersection with itself would result in duplicate listing
				tempCluster.erase(tempCluster.begin());
				//add it to the cluster vector to store
				repClusters.push_back(tempCluster);
			}
			
		}


	}*/
	
    /* readRepData reads rep data and computes the middle points in 2d image featureCoord
void Rep3D::readRepData(string folderLocation)
{
	cout<<endl<<"Read out Rep Data..."<<endl;
	cout <<"reading Path is: "<<folderLocation <<endl;
	clock_t timer = time(0);
	int sizeOfCD=colrep_data.size();
	int imageIndex;
	cout<<"this is the size of colrepData "<<sizeOfCD<<endl;
	DIR *directory;
	cout<<"started to read rep"<<endl;
	struct dirent* file;
	//opens the direcotry with the propper path
	string myLocalDir=folderLocation;
	directory = opendir(myLocalDir.c_str());

    if (directory == NULL)
    {
  			cout<<"could not find dir"<<endl;
    }
	
	while ((file=readdir(directory)) != NULL)
	{
        	//cout<<file->d_name<<endl;
			string fileName=file->d_name;
			//find the .rep2 file only and read their input
			if(fileName.substr(fileName.find_last_of(".") + 1) == "rep2"){
				//cout<<"rep1 file found "<<fileName<<endl;
				//find the image associated to the rep
				string imgName=fileName.substr(0,fileName.find_last_of("."));
				imgName=imgName+".JPG";
				//cout<<"this is the image name "<<imgName<<endl;
				//read the file
				ifstream file;
				string fileNameAdded=myLocalDir+"/"+fileName;
				//cout<<"this is the filename "<<fileNameAdded<<endl;
				bool found=false;
				for(int i=0;i<sizeOfCD;++i)
				{
				
						string tempstring="images/"+imgName+"\r";
						if(colrep_data[i].image_name==imgName || colrep_data[i].image_name==tempstring){
						//cout<<"found correspondence"<<endl;
						found=true;	
						imageIndex=i;
						break;
						}
					
				}
				if(found){
					
					//local repdata
					file.open(fileNameAdded.c_str());
					if(!file.is_open()){
						cout<<"could not open  rep2"<<endl;
					}
					else{
							string line;	
							vector<string> theActualData;
							//check what is on the first line if its zero don't go any further
							getline(file,line);
							if(line=="0")
							{
								colrep_data[imageIndex].myRep.numberOfReps=0;
							}
							else{
								//open rep2 file also to get structure
								ifstream file_rep1;
							//	string fileNameRep1=myLocalDir+"/"+fileName.substr(0,fileName.find_last_of("."))+".rep";	
								file_rep1.open(fileNameRep1.c_str());
									//cout<<"this is filename "<<fileNameRep2<<endl;
									if(!file_rep1.is_open()){
										cout<<"could not open .rep file"<<endl;
										cout<<"this is filename "<<fileNameRep1<<endl;
									}
									else{
									string daReps=line;
									//getline(file,daReps);	
									int repAmount=std::atof(daReps.c_str());
									//cout<<"there are "<<repAmount<<" reps in this file " <<fileName<<endl;	
									colrep_data[imageIndex].myRep.numberOfReps=repAmount;
										
										vector<vector<vector<pair<float,float>>>> localInfo; 
										
										for(int j=0;j<repAmount;++j){
											string localLine;
											getline(file,localLine);
											int first_dot = localLine.find_first_of(".");
											localLine=localLine.substr(0,first_dot);
											int lastSpace=localLine.find_last_of(" ");
											string lineX=localLine.substr(lastSpace-2,lastSpace);
											string lineY=localLine.substr(lastSpace,lastSpace+2);
											int x_loc=std::atof(lineX.c_str())+1;
											x_loc=2*x_loc;
											int y_loc=std::atof(lineY.c_str())+1;
											//cout<<"this is x_loc "<<x_loc<<" y_loc "<<y_loc<<endl;
											vector<vector<pair<float,float>>> theLocalVect;
											
											vector<pair<float,float>> rawInfo1;
											vector<pair<float,float>> rawInfo2;
											
											//read out the first line of document
											if(j==0){
												getline(file_rep1,localLine);	
												//cout<<"start line "<<localLine<<endl;
											}
											for(int x=0;x<x_loc;++x){
													getline(file_rep1,localLine);
												//	cout<<"this is local line "<<localLine<<endl;
													pair<float,float> theLocalPair;
													try{
													 string sA=localLine.substr(0,localLine.find_first_of(" "));
													 string sB=localLine.substr(localLine.find_first_of(" "));
													 theLocalPair.first=(float)atof(sA.c_str());
													 theLocalPair.second=(float)atof(sB.c_str());
													}
													catch(int e){
														cout<<"error in read Rep catch(int e)"<<endl;
													}
													rawInfo1.push_back(theLocalPair);
											}//end of x for loop
											
											//if there are more than 2 vertical repetitons, the information for the middle featureCoord
											//needs to be calculated
											if(y_loc>2){
												int stopper=x_loc/2;
												//read out 3 dummy lines
												for(int s=0;s<3;++s){
													getline(file_rep1,localLine);
													//cout<<"dummy line "<<localLine<<endl;
												}
												//read data into rawInfo2
												int intermediary=2*(y_loc-2);
												//<
												for(int y=0;y<intermediary;++y){
													getline(file_rep1,localLine);
													string reallyLocal=localLine;
													//cout<<"this is local line writen into "<<localLine<<endl;
													pair<float,float> theLocalPair2;
													try{
													 string sAa=reallyLocal.substr(0,reallyLocal.find_first_of(" "));
													 string sBa=reallyLocal.substr(reallyLocal.find_first_of(" "));
													 theLocalPair2.first=(float)atof(sAa.c_str());
													 theLocalPair2.second=(float)atof(sBa.c_str());
													}
													catch(int e){
														cout<<"error in read Rep catch(int e)"<<endl;
													}
													rawInfo2.push_back(theLocalPair2);
												}
												//putting data into vectors
												int r2l=rawInfo2.size();
												string name_abc=colrep_data[imageIndex].image_name;
												
												vector<pair<float,float>> rawLeft,rawRight;
												for(int a=0;a<r2l;++a){
													if(a%2==0){
														rawLeft.push_back(rawInfo2[a]);
													}
													else{
														rawRight.push_back(rawInfo2[a]);
													}
												}
												
												//fill data												
												
												int sizeStopA=rawRight.size();
												int sizeStopB=rawLeft.size();
								
												
												//leave on, not there for debugging purporse 
												if(sizeStopB!=sizeStopA){
													cout<<"big error line 572: left and right side rep vectors not the same size"<<endl;
												}
												for(int k=0;k<stopper;++k){
													vector<pair<float,float>> vec3;
													//filling left column
													if(k==0){
														vec3.push_back(rawInfo1[0]);
														for(int a=0;a<sizeStopA;++a){
															vec3.push_back(rawLeft[a]);
														}
														vec3.push_back(rawInfo1[1]);
													}
													//filling right column
													else if(k==stopper-1){
														vec3.push_back(rawInfo1[2*k]);
														for(int a=0;a<sizeStopA;++a){
															vec3.push_back(rawRight[a]);
														}
														vec3.push_back(rawInfo1[2*k+1]);
													}
													else{
														//add for as long as there are  lines
													for(int a=0;a<y_loc;++a){
														//beggining of line we have the data
														if(a==0){
															//cout<<"line 588"<<endl;
															vec3.push_back(rawInfo1[2*k]);
														}
														//end of line we have the data
														else if(a==y_loc-1){
															vec3.push_back(rawInfo1[2*k+1]);
															//cout<<"line 594"<<endl;
														}
														else{
															//define vertical line
															//poionts of interest
															//line is defined by y=mx+b
															
															pair<float,float> v1=rawInfo1[2*k];
															pair<float,float> v2=rawInfo1[2*k+1];
															//shloud be linked to k???
															pair<float,float> h1=rawLeft[a-1];
															pair<float,float> h2=rawRight[a-1];
															
															//horizontal difference of top & bottom points
															float deltaXv=v2.first-v1.first;
															//vertical difference of corner points
															float deltaYh=h2.second-h1.second;
															float x_final=0.f;
															float y_final=0.f;
															float mv,mh;
															
															//tolerance of 2 can be changed maybee up to 5-10?
															int thrld=2.f;
															//if we have a very close to square edges
															if(abs(deltaXv)<thrld && abs(deltaYh)<thrld){
																x_final=v1.first;
																y_final=h1.second;
															}
															//small x difference x is fixed, calculate y line and compute y value using x
															else if(abs(deltaXv)<thrld){
																x_final=v1.first;
																 mh=deltaYh/(h2.first-h1.first);
																float b2=-mh*+h1.second;
																 y_final=b2+mh*x_final;		
															}
															//small vertical diff of side points (right left): compute line vertically and x
															else if(abs(deltaYh)<thrld){
																//x_final; needs to be computed
																y_final=h1.second;
																 mv=(v2.second-v1.second)/deltaXv;
																float b1=-mv*v1.first+v1.second;
																x_final=(y_final-b1)/mv;
																
															}
															//else, no vertical or horizontal lines, compute using traditional method
															else{
																string name_abc=colrep_data[imageIndex].image_name;
															//if(name_abc.find("P1010608.JPG")!=string::npos){
															
															//}
																 mv=(v2.second-v1.second)/deltaXv;
																 mh=deltaYh/(h2.first-h1.first);
																float b1=-mv*v1.first+v1.second;
																float b2=-mh*h1.first+h1.second;
															 	x_final=(b2-b1)/(mv-mh);
																y_final=b2+mh*x_final;		
															}
															//cout<<"this is x_final "<<x_final <<" y_final"<<y_final<<endl;
												
															pair<float,float> localInfo={x_final,y_final};
															
															
															vec3.push_back(localInfo);
														}
													}
													//vec3.push_back(rawInfo1[k*2+1]);
												}
													theLocalVect.push_back(vec3);
												}
												//read out 3 dummy lines
												for(int s=0;s<3;++s){
													getline(file_rep1,localLine);
													//cout<<"dummy line 2 "<<localLine<<endl;
												}
											}

											else{
											//read 6 dummy lines
												for(int s=0;s<6;++s){
												getline(file_rep1,localLine);
													//cout<<"dummy line 3 "<<localLine<<endl;
												}
												//write data into theLocalVect
												//vector<vector<pair<float,float>>> vec2;
												int stopper=x_loc/2;
												for(int k=0;k<stopper;++k){
													vector<pair<float,float>> vec33;
													for(int u=0;u<2;++u){
														vec33.push_back(rawInfo1[u+2*k]);
													}
													theLocalVect.push_back(vec33);
												}
											}
												localInfo.push_back(theLocalVect);
										}//end of filling theRepIno	
										colrep_data[imageIndex].myRep.theRepInfo=localInfo;
								  }//end of else rep not open
								}						
							}
						}	
				}	
		}

	float t =difftime( time(0), timer);
	cout<<endl<<"ReadRepData done! ["<<t<<" sec]"<<endl;
	//onyl for debugging purporses
	//TestRepConst();
}*/

